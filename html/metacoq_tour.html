<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>metacoq_tour</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library metacoq_tour</h1>

<div class="code">

<br/>

<br/>
</div>

<div class="doc">
MetaCoq is: 

<div class="paragraph"> </div>

<ul class="doclist">
<li> The "template-coq" monad, dealing with reification of terms 
    and environments.

</li>
<li> The PCUIC development of the syntactic metatheory of Coq.

</li>
<li> The SafeChecker package implementing reduction, conversion 
    and typechecking in a sound and complete way.

</li>
<li> The Erasure package implementing verified extraction to 
    untyped lambda-calculus

</li>
</ul>

</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">Ast.term</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">foo</span> := (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">nat</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">nat</span> ⇒ <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">reifx'</span>.<br/>

<br/>

<br/>

<br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">typing</span>.<br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">type_Sort</span>.<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">type_LetIn</span>.<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">type_Const</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">PCUICSR.subject_reduction</span>.<br/>

<br/>
</div>

<div class="doc">
Verified conversion and type-checking 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">PCUICSafeConversion.isconv_term_sound</span>.<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">PCUICSafeConversion.isconv_term_complete</span>.<br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">PCUICSafeChecker.infer_wf_env</span>.<br/>
</div>

<div class="doc">
Proof of completeness is near completion. 
<div class="paragraph"> </div>

 Verified retyping: from a term that is known to be well-typeable, 
  compute its principal type. Very common in tactics to avoid retypechecking 
  the whole term. 
</div>
<div class="code">
<span class="id" title="keyword">Check</span> <span class="id" title="var">type_of</span>.<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">type_of_subtype</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">check_inh</span>.<br/>

<br/>
</div>

<div class="doc">
We construct a proof of typing entirely within Coq, calling the typechecker to produce the derivation 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
The extracted typechecker also runs in OCaml 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
Erasure 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
Running erasure live in Coq 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">test</span> (<span class="id" title="var">p</span> : <span class="id" title="var">Ast.Env.program</span>) : <span class="id" title="var">string</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">erase_and_print_template_program</span> <span class="id" title="var">p</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">zerocst</span> := <span class="id" title="keyword">Eval</span> <span class="id" title="tactic">lazy</span> <span class="id" title="tactic">in</span> <span class="id" title="var">test</span> <span class="id" title="var">zero</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">singleton_elim</span> := <br/>
&nbsp;&nbsp;((<span class="id" title="keyword">fun</span> (<span class="id" title="var">X</span> : <span class="id" title="keyword">Set</span>) (<span class="id" title="var">x</span> : <span class="id" title="var">X</span>) (<span class="id" title="var">e</span> : <span class="id" title="var">x</span> = <span class="id" title="var">x</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">e</span> <span class="id" title="tactic">in</span> <span class="id" title="var">eq</span> <span class="id" title="var">_</span> <span class="id" title="var">x'</span> <span class="id" title="keyword">return</span> <span class="id" title="var">bool</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">eq_refl</span> ⇒ <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>)).<br/>

<br/>

<br/>

<br/>
</div>

<div class="doc">
Conclusion: Status of MetaCoq 

<div class="paragraph"> </div>

<ul class="doclist">
<li> Correctness and complete typechecker for (a large fragment of) Coq.

<div class="paragraph"> </div>


</li>
<li> All metatheory proofs are finished. Compared to Coq's implementation:

<div class="paragraph"> </div>

<ul class="doclist">
<li> full (max (i + k, j + l)) universe support (including a naïve acyclicity checking
      algorithm)

<div class="paragraph"> </div>


</li>
<li> partial support for SProp (in programs but not yet formalized typing rules)

<div class="paragraph"> </div>


</li>
<li> approximate cumulative inductive types checking (not yet up to reduction)

<div class="paragraph"> </div>


</li>
<li> missing eta-conversion: the plan is to use contravariant subtyping and eta-reduction, 
      as in Coq CEP 47
    
    - missing template-polymorphism: we're studying a sort polymorphism extension 
      (with G. Gilbert, K. Maillard and N. Tabareau) to subsume it completely.
    
    - missing modules and fast conversion machines.

  - Much work to come on the template-coq side to ease meta-programming.

  - Relation to CertiCoq: fast and verified correct erasure, not depending on type-checking
    (only retyping).
    
    + CertiCoq needs to have all constructors eta-expanded, a proof of the
      syntactic translation expanding constructors is in progress.
    
    + Otherwise the front-end part of CertiCoq is complete with proofs. 
    
    + Future work: handling of primitive types (ints, floats, arrays, ...)
  


</li>
</ul>

</li>
</ul>
</div>
<div class="code">

<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>